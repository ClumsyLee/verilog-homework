## 处理器结构

1. 回答问题：

    a) 31 代表第 31 号寄存器 $ra。在执行 jal/jalr 时需要使用，因为运行这两条指令时，需要将下一条指令的地址（PC + 4）保存在 $ra 中。

    b) 是 shamt，即为移位量（shift amount）。在 sll/srl/sra 指令中会用到，因为这些指令需要制定位移量。

    c) 对应的是下一条指令的地址（PC + 4）。在执行 jal/jalr 时需要 MemtoReg 为 2，因为这两条指令需要将 PC + 4 写入寄存器 $ra。

    d) 对应的是 Read data 1 所读出的寄存器值。执行 jr/jalr 时需要 PCSrc 为 2，因为这两条指令需要跳转到寄存器所指示的地址。

    e) 因为要实现有符号算数和无符号算数，前者需要符号扩展，后者需要无符号扩展。执行 lw/sw/addi/addiu/andi/slti/beq 时需要 ExtOp 为 1，sltiu 时需要 ExtOp 为 0。

    f) 不需要修改。因为 nop 指令相当于 sll $zero, $zero, 0，而由于向 $zero 的写操作会被忽略，所以这条指令没有任何副作用，所以可以相当于空指令。（事实上，如果目的寄存器为 $zero 的话，基本上每条指令都会变成空指令）


2. 填写真值表

    |       | PCSrc[1:0] | Branch | RegWrite | RegDst[1:0] | MemRead | MemWrite | MemtoReg[1:0] | ALUSrc1 | ALUSrc2 | Extop | Luop |
    |-------|------------|--------|----------|-------------|---------|----------|---------------|---------|---------|-------|------|
    | lw    |          0 | 0      |        1 | 0           |       1 |        0 | 1             | 0       | 1       | 1     | 0    |
    | sw    |          0 | 0      |        0 | x           |       0 |        1 | x             | 0       | 1       | 1     | 0    |
    | lui   |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | x     | 1    |
    | add   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | addu  |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | sub   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | subu  |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | addi  |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | 1     | 0    |
    | addiu |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | 1     | 0    |
    | and   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | or    |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | xor   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | nor   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | andi  |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | 1     | 0    |
    | sll   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 1       | 0       | x     | x    |
    | srl   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 1       | 0       | x     | x    |
    | sra   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 1       | 0       | x     | x    |
    | slt   |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | sltu  |          0 | 0      |        1 | 1           |       0 |        0 | 0             | 0       | 0       | x     | x    |
    | slti  |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | 1     | 0    |
    | sltiu |          0 | 0      |        1 | 0           |       0 |        0 | 0             | 0       | 1       | 0     | 0    |
    | beq   |          0 | 1      |        0 | x           |       0 |        0 | x             | 0       | 0       | 1     | 0    |
    | j     |          1 | x      |        0 | x           |       0 |        0 | x             | x       | x       | x     | x    |
    | jal   |          1 | x      |        1 | 2           |       0 |        0 | 2             | x       | x       | x     | x    |
    | jr    |          2 | x      |        0 | x           |       0 |        0 | x             | x       | x       | x     | x    |
    | jalr  |          2 | x      |        1 | 2           |       0 |        0 | 2             | x       | x       | x     | x    |


## 完成控制器

3. 执行足够长时间后，程序会一直运行第 11 行，即不停无条件跳转到本条语句而死循环。

    程序的执行过程如下：

     0: $a0 <= 0x00003039  (0x0 + 0x00003039)
     1: $a1 <= 0xffffd431  (0x0 + 0xffffd431, 立即数符号扩展)
     2: $a2 <= 0xd4310000  (0xffffd431 << 16)
     3: $a3 <= 0xffffd431  (0xd4310000 >> 16, 算术右移)
     4:                    ($a3 == $a1, 跳转至 L1)
     6: $t0 <= 0xd4313039  (0xd4310000 + 0x00003039)
     7: $t1 <= 0xffd43130  (0xd4313039 >> 8)
     8: $t2 <= 0xffffcfc7 (0x0 + 0xffffcfc7, 立即数符号扩展)
     9: $v0 <= 0x00000000  (0x00003039 ≮ 0xffffcfc7, 有符号数比较)
    10: $v1 <= 0x00000001  (0x00003039 < 0xffffcfc7, 无符号数比较)
    11:                    (进入死循环)

    各个寄存器的终值如上所示。

    如果某一时刻一寄存器中放着 0xffffcfc7，不能判断其是有符号数还是无符号数。

    因为有符号数和无符号数在存储时没有区别，只是在进行具体操作是可以将其看做有符号/无符号数。

    例如上面程序中 9 - 10 行中的 slt 和 sltu，都是对 $t2 进行操作，不过 slt 将 $t2 看做有符号数， sltu 将 $t2 看做无符号数。

4. 观察仿真结果

    a) PC 从 0x00000000 变化到了 0x0000002c

    b) Branch 信号在 400~500ns 时为 1。它使 PC 从 0x00000010 跳转到了 0x00000018，即增加了 8。

    c) 100~200ns 期间 PC 为 0x00000004，对应着 addiu $a1, $zero, -11215。

        此时 $a1 的值是 0x00000000，200~300ns $a1 的值是 0xffffd431。因为在 200ns 时钟上升沿到来时，前一时钟周期计算出的 $a0 的新值才被写入寄存器文件。

        下条指令立即使用 $a1 不会出现错误，因为在下个时钟周期开始时 $a1 的新值已经写入了，故当电路稳定后，读到的 $a1 的值一定是新值。

    d) 运行足够长时间后，各寄存器的值为：

        $a0: 0x00003039
        $a1: 0xffffd431
        $a2: 0xd4310000
        $a3: 0xffffd431
        $t0: 0xd4313039
        $t1: 0xffd43130
        $t2: 0xffffcfc7
        $v0: 0x00000000
        $v1: 0x00000001

        和预期一致。


## 执行汇编程序

1. 这段程序的功能是计算 1 + 2 + ... + n。

    * `Loop` 使程序死循环，停在这一条语句。
    * `sum` 是 sum 函数的入口。
    * `L1` 所在的分支递归调用了 sum 函数，从而递归实现了求和的功能。

    程序及注释如下：

    ```
          addi $a0, $zero, 3      # $a0 = n
          jal sum                 # Call sum(n)
    Loop:
          beq $zero, $zero, Loop  # Stuck in here
    sum:                          # Calculate sum(i)
          addi $sp, $sp, -8       # Allocate space on stack
          sw $ra, 4($sp)          # Save return address
          sw $a0, 0($sp)          # Save argument i
          slti $t0, $a0, 1        # Set $t0 to 1 if i < 1
          beq $t0, $zero, L1      # Go to L1 if i >= 1
          xor $v0, $zero, $zero   # Set return value to 0
          addi $sp, $sp, 8        # Free stack space
          jr $ra                  # Return 0 if i < 1
    L1:
          addi $a0, $a0, -1       # $a0 = i - 1
          jal sum                 # Call sum(i - 1)
          lw $a0, 0($sp)          # Restore argument i
          lw $ra, 4($sp)          # Restore return address
          addi $sp, $sp, 8        # Free stack space
          add $v0, $a0, $v0       # Add i to return value of sum(i - 1)
          jr $ra                  # return i + sum(i - 1)
    ```

2. 机器码如下：

    ```
    0000000: 001000  00000  00100  00000  00000  000011
    0000004: 000011  00000  00000  00000  00000  000011
    0000008: 000100  00000  00000  11111  11111  111111
    000000c: 001000  11101  11101  11111  11111  111000
    0000010: 101011  11101  11111  00000  00000  000100
    0000014: 101011  11101  00100  00000  00000  000000
    0000018: 001010  00100  01000  00000  00000  000001
    000001c: 000100  01000  00000  00000  00000  000011
    0000020: 000000  00000  00000  00010  00000  100110
    0000024: 001000  11101  11101  00000  00000  001000
    0000028: 000000  11111  00000  00000  00000  001000
    000002c: 001000  00100  00100  11111  11111  111111
    0000030: 000011  00000  00000  00000  00000  000011
    0000034: 100011  11101  00100  00000  00000  000000
    0000038: 100011  11101  11111  00000  00000  000100
    000003c: 001000  11101  11101  00000  00000  001000
    0000040: 000000  00100  00010  00010  00000  100000
    0000044: 000000  11111  00000  00000  00000  001000
    ```

    其中左方为指令地址。

    beq 中的 Loop, L1 翻译成了相对地址，即标签所指指令相对 beq 下一条指令的偏移量 / 4。例如，beq $zero, $zero, Loop 中的 Loop 便翻译成了 -1。

    jal 中的 sum 则翻译成了指令的绝对地址 / 4，即为 sum 代表的指令在内存中的位置 / 4 = 3。

    立即数 -1 翻译成了 0xFFFF，-8 翻译成了 0xFFF8。

3. 运行仿真

    a) 运行时间足够长之后，$a0 = 0x00000003, $v0 = 0x00000006

        预期结果：

        $a0 = 最外层 sum 函数调用的参数 = 3

        $v0 = sum(3) = 1 + 2 + 3 = 6

        仿真结果与预期相符。

    b) 

